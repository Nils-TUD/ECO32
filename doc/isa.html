<HTML>
<HEAD>
<TITLE>Assembler Short Reference</TITLE>
</HEAD>
<BODY>

<H2>
ECO32 Instruction Set Architecture
</H2>

<TABLE BORDER=1>
<TR><TH> Format </TH><TH> Description                                                    </TH></TR>
<TR><TD> N      </TD><TD> no operands                                                    </TD></TR>
<TR><TD> RH     </TD><TD> one register and the lower 16 bits of a word                   </TD></TR>
<TR><TD> RHH    </TD><TD> one register and the upper 16 bits of a word                   </TD></TR>
<TR><TD> RRH    </TD><TD> two registers and a zero-extended halfword                     </TD></TR>
<TR><TD> RRS    </TD><TD> two registers and a sign-extended halfword                     </TD></TR>
<TR><TD> RRR    </TD><TD> three registers                                                </TD></TR>
<TR><TD> RRX    </TD><TD> three registers, or two registers and a zero-extended halfword </TD></TR>
<TR><TD> RRY    </TD><TD> three registers, or two registers and a sign-extended halfword </TD></TR>
<TR><TD> RRB    </TD><TD> two registers and a sign-extended 16 bit offset                </TD></TR>
<TR><TD> J      </TD><TD> no registers and a sign-extended 26 bit offset                 </TD></TR>
<TR><TD> JR     </TD><TD> one register                                                   </TD></TR>
</TABLE>

<BR>

<TABLE BORDER=1>
<TR><TH> Mnemonic </TH><TH> Operands         </TH><TH> Description                                      </TH><TH> Format </TH></TR>
<TR><TD> add      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 + op2                                 </TD><TD> RRY    </TD></TR>
<TR><TD> sub      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 - op2                                 </TD><TD> RRY    </TD></TR>
<TR><TD> mul      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 * op2, signed                         </TD><TD> RRY    </TD></TR>
<TR><TD> mulu     </TD><TD> dst, op1, op2    </TD><TD> dst := op1 * op2, unsigned                       </TD><TD> RRX    </TD></TR>
<TR><TD> div      </TD><TD> dst, op1, op2    </TD><TD> dst := op1 / op2, signed                         </TD><TD> RRY    </TD></TR>
<TR><TD> divu     </TD><TD> dst, op1, op2    </TD><TD> dst := op1 / op2, unsigned                       </TD><TD> RRX    </TD></TR>
<TR><TD> rem      </TD><TD> dst, op1, op2    </TD><TD> dst := remainder of op1/op2, signed              </TD><TD> RRY    </TD></TR>
<TR><TD> remu     </TD><TD> dst, op1, op2    </TD><TD> dst := remainder of op1/op2, unsigned            </TD><TD> RRX    </TD></TR>
<TR><TD> and      </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise AND of op1 and op2                </TD><TD> RRX    </TD></TR>
<TR><TD> or       </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise OR of op1 and op2                 </TD><TD> RRX    </TD></TR>
<TR><TD> xor      </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise XOR of op1 and op2                </TD><TD> RRX    </TD></TR>
<TR><TD> xnor     </TD><TD> dst, op1, op2    </TD><TD> dst := bitwise XNOR of op1 and op2               </TD><TD> RRX    </TD></TR>
<TR><TD> sll      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 logically left by op2           </TD><TD> RRX    </TD></TR>
<TR><TD> slr      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 logically right by op2          </TD><TD> RRX    </TD></TR>
<TR><TD> sar      </TD><TD> dst, op1, op2    </TD><TD> dst := shift op1 arithmetically right by op2     </TD><TD> RRX    </TD></TR>
<TR><TD> ldhi     </TD><TD> dst, op1         </TD><TD> dst := op1 shifted left by 16 bits               </TD><TD> RHH    </TD></TR>
<TR><TD> beq      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 == op2            </TD><TD> RRB    </TD></TR>
<TR><TD> bne      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 != op2            </TD><TD> RRB    </TD></TR>
<TR><TD> ble      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <= op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bleu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <= op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> blt      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <  op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bltu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 <  op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> bge      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >= op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bgeu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >= op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> bgt      </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >  op2 (signed)   </TD><TD> RRB    </TD></TR>
<TR><TD> bgtu     </TD><TD> op1, op2, offset </TD><TD> branch to PC+4+offset*4 if op1 >  op2 (unsigned) </TD><TD> RRB    </TD></TR>
<TR><TD> j        </TD><TD> offset           </TD><TD> jump to PC+4+offset*4                            </TD><TD> J      </TD></TR>
<TR><TD> jr       </TD><TD> register         </TD><TD> jump to register                                 </TD><TD> JR     </TD></TR>
<TR><TD> jal      </TD><TD> offset           </TD><TD> jump to PC+4+offset*4, store PC+4 in $31         </TD><TD> J      </TD></TR>
<TR><TD> jalr     </TD><TD> register         </TD><TD> jump to register, store PC+4 in $31              </TD><TD> JR     </TD></TR>
<TR><TD> trap     </TD><TD> -/-              </TD><TD> cause a trap, store PC in $30                    </TD><TD> N      </TD></TR>
<TR><TD> rfx      </TD><TD> -/-              </TD><TD> return from exception, restore PC from $30       </TD><TD> N      </TD></TR>
<TR><TD> ldw      </TD><TD> dst, reg, offset </TD><TD> dst := word @ (reg+offset)                       </TD><TD> RRS    </TD></TR>
<TR><TD> ldh      </TD><TD> dst, reg, offset </TD><TD> dst := sign-extended halfword @ (reg+offset)     </TD><TD> RRS    </TD></TR>
<TR><TD> ldhu     </TD><TD> dst, reg, offset </TD><TD> dst := zero-extended halfword @ (reg+offset)     </TD><TD> RRS    </TD></TR>
<TR><TD> ldb      </TD><TD> dst, reg, offset </TD><TD> dst := sign-extended byte @ (reg+offset)         </TD><TD> RRS    </TD></TR>
<TR><TD> ldbu     </TD><TD> dst, reg, offset </TD><TD> dst := zero-extended byte @ (reg+offset)         </TD><TD> RRS    </TD></TR>
<TR><TD> stw      </TD><TD> src, reg, offset </TD><TD> store src word @ (reg+offset)                    </TD><TD> RRS    </TD></TR>
<TR><TD> sth      </TD><TD> src, reg, offset </TD><TD> store src halfword @ (reg+offset)                </TD><TD> RRS    </TD></TR>
<TR><TD> stb      </TD><TD> src, reg, offset </TD><TD> store src byte @ (reg+offset)                    </TD><TD> RRS    </TD></TR>
<TR><TD> mvfs     </TD><TD> dst, special     </TD><TD> dst := contents of special register              </TD><TD> RH     </TD></TR>
<TR><TD> mvts     </TD><TD> src, special     </TD><TD> contents of special register := src              </TD><TD> RH     </TD></TR>
<TR><TD> tbs      </TD><TD> -/-              </TD><TD> TLB search                                       </TD><TD> N      </TD></TR>
<TR><TD> tbwr     </TD><TD> -/-              </TD><TD> TLB write random                                 </TD><TD> N      </TD></TR>
<TR><TD> tbri     </TD><TD> -/-              </TD><TD> TLB read index                                   </TD><TD> N      </TD></TR>
<TR><TD> tbwi     </TD><TD> -/-              </TD><TD> TLB write index                                  </TD><TD> N      </TD></TR>
</TABLE>

<BR>

<TABLE BORDER=1>
<TR><TH COLSPAN=8> Integer Registers </TH></TR>
<TR>
<TD> $0  </TD> <TD> always zero                      </TD>
<TD> $8  </TD> <TD> temporary register (caller-save) </TD>
<TD> $16 </TD> <TD> register variable  (callee-save) </TD>
<TD> $24 </TD> <TD> temporary register (caller-save) </TD>
</TR>
<TR>
<TD> $1  </TD> <TD> reserved for assembler           </TD>
<TD> $9  </TD> <TD> temporary register (caller-save) </TD>
<TD> $17 </TD> <TD> register variable  (callee-save) </TD>
<TD> $25 </TD> <TD> temporary register (caller-save) </TD>
</TR>
<TR>
<TD> $2  </TD> <TD> func return value                </TD>
<TD> $10 </TD> <TD> temporary register (caller-save) </TD>
<TD> $18 </TD> <TD> register variable  (callee-save) </TD>
<TD> $26 </TD> <TD> reserved for OS kernel           </TD>
</TR>
<TR>
<TD> $3  </TD> <TD> func return value                </TD>
<TD> $11 </TD> <TD> temporary register (caller-save) </TD>
<TD> $19 </TD> <TD> register variable  (callee-save) </TD>
<TD> $27 </TD> <TD> reserved for OS kernel           </TD>
</TR>
<TR>
<TD> $4  </TD> <TD> proc/func argument               </TD>
<TD> $12 </TD> <TD> temporary register (caller-save) </TD>
<TD> $20 </TD> <TD> register variable  (callee-save) </TD>
<TD> $28 </TD> <TD> reserved for OS kernel           </TD>
</TR>
<TR>
<TD> $5  </TD> <TD> proc/func argument               </TD>
<TD> $13 </TD> <TD> temporary register (caller-save) </TD>
<TD> $21 </TD> <TD> register variable  (callee-save) </TD>
<TD> $29 </TD> <TD> stack pointer                    </TD>
</TR>
<TR>
<TD> $6  </TD> <TD> proc/func argument               </TD>
<TD> $14 </TD> <TD> temporary register (caller-save) </TD>
<TD> $22 </TD> <TD> register variable  (callee-save) </TD>
<TD> $30 </TD> <TD> interrupt return address         </TD>
</TR>
<TR>
<TD> $7  </TD> <TD> proc/func argument               </TD>
<TD> $15 </TD> <TD> temporary register (caller-save) </TD>
<TD> $23 </TD> <TD> register variable  (callee-save) </TD>
<TD> $31 </TD> <TD> proc/func return address         </TD>
</TR>
</TABLE>

<BR>

<TABLE BORDER=1>
<TR><TH COLSPAN=8> Special Registers </TH></TR>
<TR>
<TD>0</TD><TD> Processor Status </TD>
</TR>
<TR>
<TD>1</TD><TD> TLB Index        </TD>
<TD>2</TD><TD> TLB Entry High   </TD>
<TD>3</TD><TD> TLB Entry Low    </TD>
<TD>4</TD><TD> TLB Bad Address  </TD>
</TR>
</TABLE>

<BR>

<TABLE BORDER=1>
<TR>
	<TH COLSPAN=9> Processor Status Register </TH>
</TR><TR>
	<TD> 31 .. 27 </TD>
	<TD> 26 </TD><TD> 25 </TD><TD> 24 </TD>
	<TD> 23 </TD><TD> 22 </TD><TD> 21 </TD>
	<TD> 20 .. 16 </TD>
	<TD> 15 .. 0 </TD>
</TR><TR>
	<TD></TD>
	<TD COLSPAN=3> User Mode </TD>
	<TD COLSPAN=3> Interrupt Enable </TD>
	<TD> Priority </TD>
	<TD> Interupt Mask </TD>
</TR><TR>
	<TD></TD>
	<TD> Cur </TD><TD> Prv </TD><TD> Old </TD>
	<TD> Cur </TD><TD> Prv </TD><TD> Old </TD>
	<TD> 0 .. 31 </TD>
	<TD></TD>
</TR>
</TABLE>

</BODY>
</HTML>
